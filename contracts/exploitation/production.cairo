%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.starknet.common.syscalls import get_block_timestamp
from starkware.cairo.common.bool import TRUE
from starkware.cairo.common.math import unsigned_div_rem, abs_value, sqrt
from starkware.cairo.common.pow import pow
from starkware.cairo.common.math_cmp import is_nn, is_le
from contracts.map.biomes import get_temperature
from contracts.world import world, Plot
from contracts.utils.fixed_point_numbers import (
    Math64x61_div as div,
    Math64x61_toFelt as to_felt,
    Math64x61_mul as mul
)

# To learn more about Eykar resources and extraction see our wiki: (insert link)


########### EXTRACTION FUNCTIONS ##########


func renewable_extraction{range_check_ptr}(t: felt, alpha: felt, sqrt_alpha: felt) -> (amount: felt):
    # Gives the plot renewable resource amount over time.
    #
    # Parameters:
    #   t: current timestamp
    #   alpha: amount modifier
    #   sqrt_alpha: sqrt(alpha)
    #
    # Returns:
    #   amount: resource amount at instant t
    alloc_locals
    let (_, t_reduced) = unsigned_div_rem(t, 2 * sqrt_alpha)
    let (temp) = pow(t_reduced-sqrt_alpha, 3)
    let (abs_temp) = abs_value(temp)
    let (temp_div_1, _) = unsigned_div_rem(abs_temp, alpha)
    let (temp_div_2, _) = unsigned_div_rem(3 * sqrt_alpha, 5)

    let (temp) = is_nn(temp)
    if temp == TRUE:
        return (t_reduced - temp_div_1 - temp_div_2)
    else:
        return (t_reduced + temp_div_1 - temp_div_2)
    end
end

const FRACT_PART = 2 ** 61

func non_renew_extraction{range_check_ptr}(t: felt, K: felt) -> (amount: felt):
    # Gives the plot non renewable resource amount over time. Uses 64x61 fixed point format.
    #
    # Parameters:
    #   t: current timestamp (felt)
    #   K: initial amount (felt)
    #
    # Returns:
    #   amount: resource amount at instant t (felt)
    alloc_locals
    let (t_5) = pow(t, 5)
    let (K_5) = pow(K, 5)
    let (sqrt_t) = sqrt(t)
    let (temp) = div(t_5 * FRACT_PART, K_5 * sqrt_t * FRACT_PART)
    let (res) = div(K * FRACT_PART, FRACT_PART + temp)
    let (amount) = to_felt(res)
    return (amount)
end

func get_alpha{range_check_ptr}(x: felt, y: felt) -> (alpha: felt, sqrt_alpha: felt):
    # Compute alpha modifier for wood directly from coordinates, depending on elevation.
    # alpha = (1000 + (1 - |temperature - 0.4|)**2 * 1000)**2
    #
    # Parameters:
    #   x: x-coordinate of the plot
    #   y: y-coordinate of the plot
    #
    # Returns:
    #   alpha: the alpha modifier
    #   sqrt_alpha: sqrt(alpha)
    alloc_locals
    const FOUR_TENTH = 922337203685477632
    const THOUSAND = 2305843009213693952000
    let (temperature) = get_temperature(x * FRACT_PART, y * FRACT_PART)
    let (temp) = abs_value(FOUR_TENTH - temperature)
    let (temp) = mul(temp, temp)
    let (temp) = mul(THOUSAND, temp)
    let (sqrt_alpha) = to_felt(temp + THOUSAND)
    return (sqrt_alpha * sqrt_alpha, sqrt_alpha)
end

func get_k_modifier{range_check_ptr}(x: felt, y: felt) -> (k: felt):
    return (1000)
end


########## PRODUCTION FUNCTIONS ##########

func get_max_value{range_check_ptr}(alpha: felt, sqrt_alpha: felt) -> (max_value: felt):
    let (res, _)  = unsigned_div_rem(4 * sqrt_alpha, 5)
    return (res)
end

func get_cycle_lenght(sqrt_alpha: felt) -> (lenght: felt):
    return (2 * sqrt_alpha)
end

func get_cycles_number{range_check_ptr}(t: felt, l_h_t: felt, lenght: felt) -> (cycles: felt):
    let (n, _) = unsigned_div_rem(t - l_h_t, lenght)
    return (n)
end

func get_cycle_amount{}() -> (amount: felt):

end

func renewable_production{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    x: felt, y: felt
) -> (amount: felt):
    # Calculates current renewable resource production since last harvest.
    #
    # Parameters:
    #   x: x-Coordinate of the plot
    #   y: y-Coordinate of the plot
    #
    # Returns:
    #   amount: number of resource produced
    alloc_locals
    let (alpha, sqrt_alpha) = get_alpha(x, y)
    let (plot) = world.read(x, y)
    let (t) = get_block_timestamp()
    let l_h_t = plot.availability

    let (amount_t) = renewable_extraction(t, alpha, sqrt_alpha)
    let (amount_l_h) = renewable_extraction(l_h_t, alpha, sqrt_alpha)

    let (lenght) = get_cycle_lenght(sqrt_alpha)
    let (_, r) = unsigned_div_rem(l_h_t, lenght)
    let first_remains = lenght - r
    let (diff) = abs_value(t - l_h_t)

    let (condition) = is_le(diff, first_remains)
    if condition == TRUE:
        let (res) = abs_value(amount_l_h - amount_t)
    else:
        # cas difficile -> calcul du nombre de cycles
        let (n) = get_cycles_number(t, l_h_t)
        let (entire_amount) = get_cycle_amount()
        let res = n * entire_amount
    end

    world.write(x, y, Plot(plot.owner, plot.structure, t))
    return (res)
end

func non_renewable_production{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    x: felt, y: felt
) -> (amout: felt):
    # Calculates current non-renewable resource production since last harvest.
    #
    # Parameters:
    #   x: x-Coordinate of the plot
    #   y: y-Coordinate of the plot
    #
    # Returns:
    #   amount: number of resource produced
    alloc_locals
    let (k) = get_k_modifier(x, y)
    let (plot) = world.read(x, y)
    let (t) = get_block_timestamp()
    let (l_h_amount) = non_renew_extraction(plot.availability, k)
    let (t_amount) = non_renew_extraction(t, k)
    world.write(x, y, Plot(plot.owner, plot.structure, t))
    let (res) = abs_value(l_h_amount - t_amount)
    return(res)
end