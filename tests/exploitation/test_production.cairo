%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.math_cmp import is_le
from starkware.cairo.common.bool import TRUE
from contracts.eykar import mint
from contracts.exploitation.production import (
    renewable_extraction,
    non_renew_extraction,
    get_alpha,
    get_k_modifier,
    non_renewable_production,
    renewable_production,
    get_cycles_number,
    get_max_value,
    get_cycle_lenght
)

@view
func test_renewable_extraction{range_check_ptr}():
    alloc_locals
    let (extraction_1) = renewable_extraction(345, 49, 7)
    let (extraction_2) = renewable_extraction(766666, 100, 10)
    let (extraction_3) = renewable_extraction(3, 121, 11)
    let (extraction_4) = renewable_extraction(999999999, 1000000, 1000)

    assert extraction_1 = 5
    assert extraction_2 = 0
    assert extraction_3 = 1
    assert extraction_4 = 402

    return ()
end

@view
func test_non_renewable_extraction{range_check_ptr}():
    alloc_locals
    let (extraction_1) = non_renew_extraction(407, 1000)
    let (extraction_2) = non_renew_extraction(4750, 776)
    let (extraction_3) = non_renew_extraction(1240, 970)
    let (extraction_4) = non_renew_extraction(420, 200)

    assert extraction_1 = 999
    assert extraction_2 = 6
    assert extraction_3 = 883
    assert extraction_4 = 65
    return ()
end

@view
func test_get_alpha{range_check_ptr}():
    alloc_locals
    let (alpha, _) = get_alpha(545, 50)
    let (res1_a) = is_le(alpha, 4000000)
    let (res1_b) = is_le(1000000, alpha)

    let (alpha, _) = get_alpha(755, -33)
    let (res2_a) = is_le(alpha, 4000000)
    let (res2_b) = is_le(1000000, alpha)

    let (alpha, _) = get_alpha(1000, -281)
    let (res3_a) = is_le(alpha, 4000000)
    let (res3_b) = is_le(1000000, alpha)

    let (alpha1, _) = get_alpha(1231, -381)
    let (alpha2, _) = get_alpha(2016, 1281)
    let (res_4) = is_le(alpha1, alpha2)
    let (res_5) = is_le(alpha, alpha2)

    assert res1_a = TRUE
    assert res1_b = TRUE
    assert res2_a = TRUE
    assert res2_b = TRUE
    assert res3_a = TRUE
    assert res3_b = TRUE
    assert res_4 = TRUE
    assert res_5 = TRUE
    return ()
end

@view
func test_non_renewable_production{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*
}():
    alloc_locals
    let (k) = get_k_modifier(0, 0)
    let (extraction_0) = non_renew_extraction(0, k)
    let (extraction_1) = non_renew_extraction(1, k)
    let (extraction_3600) = non_renew_extraction(3600, k)

    %{ warp(0) %}
    mint('hello')
    %{ warp(1) %}
    let (production_1) = non_renewable_production(0, 0)
    %{ warp(3600) %}
    let (production_2) = non_renewable_production(0, 0)

    assert production_1 = extraction_0 - extraction_1
    assert production_2 = extraction_1 - extraction_3600
    return ()
end

@view
func test_renewable_production{
    syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*
}():
    alloc_locals
    let (alpha, sqrt_alpha) = get_alpha(0, 0)
    let (lenght) = get_cycle_lenght(sqrt_alpha)
    let (cycle_amount) = get_max_value(sqrt_alpha)
    let (n_1) = get_cycles_number(1, 0, lenght)
    let (current_amount_1) = renewable_extraction(1, alpha, sqrt_alpha)
    let (n_2) = get_cycles_number(3600, 1, lenght)
    let (current_amount_2) = renewable_extraction(3600, alpha, sqrt_alpha)

    %{ warp(0) %}
    mint('hello')
    %{ warp(1) %}
    let (production_1) = renewable_production(0, 0)
    %{ warp(3600) %}
    let (production_2) = renewable_production(0, 0)

    assert production_1 = n_1 * cycle_amount + current_amount_1
    assert production_2 = n_2 * cycle_amount + current_amount_2
    return ()
end